# MODULES (EXTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
import re
import logging
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Optional
# ---------------------------------------------------------------------------------------------------------------------

# MODULES (INTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
from src.models import *
from common.constants import ALGORITHM
from src.utils.metrics import module_metrics
# ---------------------------------------------------------------------------------------------------------------------

# MAIN PARSING REGEXES
# ---------------------------------------------------------------------------------------------------------------------
# IMPORTANT:
#   These regular expressions cover the most common cases of C# syntax, 
#   but they are not a substitute for a formal parser, if false positives 
#   or negatives appear in large projects, this is where you should adjust 
#   the logic

# Detects definitions of classes, interfaces, records, and structs
CLASS_RE = re.compile(
    r'^\s*(?:public|internal|protected|private)?\s*'
    r'(?:abstract|sealed|static|partial)?\s*'
    r'(class|record|struct|interface)\s+([A-Za-z_][A-Za-z0-9_]*)\b',
    re.MULTILINE
)

# Detects methods within the body of a class
METHOD_RE = re.compile(
    r'^\s*(?:public|private|protected|internal)\s*'
    r'(?:static\s+|virtual\s+|override\s+|async\s+|sealed\s+|partial\s+)*'
    r'[\w<>\[\],\s]+\s+([A-Za-z_][A-Za-z0-9_]*)\s*\([^)]*\)\s*{?',
    re.MULTILINE
)

# Detects attributes/properties
ATTRIBUTE_RE = re.compile(
    r'^\s*(?:public|private|protected|internal)\s*'
    r'(?:static\s+|readonly\s+|const\s+)?'
    r'[\w<>\[\],\s]+\s+([A-Za-z_][A-Za-z0-9_]*)\s*'
    r'(?:{[^}]*}|=>|=|;)',
    re.MULTILINE
)

# Detect using (includes global and alias)
USING_RE = re.compile(
    r'^\s*(?:global\s+)?using\s+(?:static\s+)?'
    r'(?:[A-Za-z_][A-Za-z0-9_]*\s*=\s*)?'
    r'([A-Za-z_][A-Za-z0-9_.]*)\s*;',
    re.MULTILINE
)

# Detect file namespace
NAMESPACE_RE = re.compile(
    r'^\s*namespace\s+([A-Za-z_][A-Za-z0-9_.]*)\s*(?:{|;)',
    re.MULTILINE
)
# ---------------------------------------------------------------------------------------------------------------------

# OPERATIONS / CLASS CREATION / GENERAL FUNCTIONS
# ---------------------------------------------------------------------------------------------------------------------

__all__ = ['analyze_csharp']

logger = logging.getLogger(ALGORITHM)
"""
Instance of the logger used by the analysis module.
"""

def analyze_csharp(path: Path) -> ModuleInfo:
    """
    Analyzes a C# file, obtaining structural information: classes, methods, attributes, 
    XML documentation, and metrics.

    This parser does NOT use the C# compiler, but rather regular expressions + manual analysis. 
    
    **This means:**
        - Easier to maintain.
        - Faster.
        - But not perfect: if the syntax is very complex, there may be unsupported cases.

    **The most sensitive areas are:**
        1. CLASS_RE, METHOD_RE, ATTRIBUTE_RE → to improve detection.
        2. Key block delimitation → important to avoid false hits.
        3. XML docstring processing → to further enrich data extraction.

    Args:
        path (Path):
            Path of the C# file to be analyzed.

    Returns:
        ModuleInfo:
            Object with all the structural and documentary information of the C# file.
    """
    src = path.read_text(encoding='utf-8', errors='ignore')
    src = src.lstrip('\ufeff') # Remove the BOM, which is common in files generated by Windows tools
    lines = src.splitlines()

    classes: List[ClassInfo] = []

    for cls_match in CLASS_RE.finditer(src):
        cls_name = cls_match.group(2)
        cls_lineno = src.count('\n', 0, cls_match.start()) + 1 # Exact line where the class begins
        cls_info = ClassInfo(
            name=cls_name, 
            lineno=cls_lineno, 
            doc=_collect_xml_text(lines, cls_lineno - 1), 
            decorators=_collect_decorators(lines, cls_lineno - 1)
        )

        # Search for the nearest { key after the declaration
        # This counter-based system works because C# uses well-defined curly braces
        # But it would fail if there were curly braces inside multi-line text literals (very rare)
        idx_brace = src.find('{', cls_match.end())
        if idx_brace == -1:
            kind = cls_match.group(1) # class, record, struct, interface
            logger.warning(f"Could not find '{{' for {kind} {cls_name} in {path.name} (Line {cls_lineno})")
            classes.append(cls_info)
            continue

        block = _extract_text_block(src, idx_brace)

        # It is compiled dynamically because the constructor name = class name
        CONSTRUCTOR_RE = re.compile(
            rf'^\s*(?:public|private|protected|internal)\s*'
            rf'(?:static\s+)?'
            rf'{re.escape(cls_name)}\s*\([^)]*\)\s*{{?',
            re.MULTILINE
        )

        for ctor in CONSTRUCTOR_RE.finditer(block):
            ctor_lineno = src.count('\n', 0, idx_brace + ctor.start()) + 1
            cls_info.methods.append(
                FunctionInfo(
                    name=cls_name, 
                    lineno=ctor_lineno, 
                    doc=_collect_xml_text(lines, ctor_lineno - 1)
                )
            )

        for method in METHOD_RE.finditer(block):
            method_lineno = src.count('\n', 0, idx_brace + method.start()) + 1
            cls_info.methods.append(
                FunctionInfo(
                    name=method.group(1),
                    lineno=method_lineno,
                    doc=_collect_xml_text(lines, method_lineno - 1),
                    decorators=_collect_decorators(lines, method_lineno - 1)
                )
            )

        for attr in ATTRIBUTE_RE.finditer(block):
            attr_lineno = src.count('\n', 0, idx_brace + attr.start()) + 1
            cls_info.attributes.append(
                AttributeInfo(
                    name=attr.group(1), 
                    lineno=attr_lineno, 
                    doc=_collect_xml_text(lines, attr_lineno - 1)
                )
            )

        classes.append(cls_info)

    return ModuleInfo(
        path=str(path),
        doc=None,           # C# does not have docstrings at the module level
        functions=[],       # C# does not have typical top-level functions
        classes=classes,
        imports=_collect_imports(src),
        metrics=module_metrics(src, classes, [])
    )

# TODO:
# It is not a formal C# parser: if there are curly braces `{` or `}` within strings, comments 
# or multiline literals, the count may be off and return an incorrect block
def _extract_text_block(src: str, idx_brace: int) -> str:
    """
    Extracts the block of text delimited by curly brackets `{ ... }` starting from an initial position.

    This block is used to limit searches with regular expressions (methods, attributes, constructors) to 
    the body of a class/struct/record/interface, avoiding false positives outside its scope.

    Args:
        src (str):
            Complete content of the C# file in text format.

        idx_brace (int):
            Index (0-based) within src where the opening brace `{` of the block to be extracted is located.

    Returns:
        str:
            Substring of the source code representing the block delimited by braces, from `src[idx_brace]` 
            to just before the matching closing brace.
    """
    depth = 0
    idx_end = len(src)
    idx_loop = idx_brace

    while idx_loop < len(src):
        if src[idx_loop] == '{':
            depth += 1
        elif src[idx_loop] == '}':
            depth -= 1
            if depth == 0:
                idx_end = idx_loop
                break
        else:
            pass # Other characters are ignored; only braces affect block depth
        
        idx_loop += 1

    return src[idx_brace:idx_end]

def _collect_xml_text(lines: List[str], start_idx: int) -> Optional[str]:
    """
    Extracts, interprets, and converts XML documentation preceding a class or method.

    This type of documentation consists of lines beginning with `///`.

    The algorithm ascends from `start_idx`, collecting all immediately preceding documentation,
    sorting it, and then parsing it as valid XML.

    **The function:**
        - Detects `<summary>`
        - Detects `<param name="x">`
        - Detects `<returns>`
        - Detects `<exception cref="X">`
        - Converts `<see cref="X"/>` nodes to plain text (X)
        - Generates a structured block of readable text

    If the block is not valid XML or does not contain relevant tags, it is returned as is.

    **Notes:**
        - This method is delicate: the logic depends on the exact order of lines.
        - To extend and support more XML tags, it must be done here.

    Args:
        lines (List[str]):
            List of lines from the source file.

        start_idx (int):
            Index where the class or method appears, used to search documentation upwards.

    Returns:
        (str | None):
            Processed and cleaned text from the documentation, or None if there is no associated documentation.
    """
    idx = start_idx - 1
    buffer: List[str] = []

    # It ascends by collecting lines with C# XML format: /// ...
    while idx >= 0:
        txt = lines[idx].rstrip()

        # The 3 slashes are removed and the content is stored
        if txt.strip().startswith('///'):
            buffer.append(txt.strip().lstrip('/').strip())
            idx -= 1
            continue

        # Blank lines are allowed between documentation
        if txt.strip() == '':
            idx -= 1
            continue

        # If an attribute [Something] exists, the search continues upwards
        if txt.strip().startswith('[') and txt.strip().endswith(']'):
            idx -= 1
            continue

        break

    if not buffer:
        return None

    buffer.reverse()
    raw = '\n'.join(buffer)

    if not any(tag in raw for tag in ('<summary', '<param', '<returns', '<exception')):
        return raw

    # It is wrapped in a <root> to make it valid XML
    try:
        root = ET.fromstring(f'<root>\n{raw}\n</root>')
        return _format_xml_documentation(root)
    except Exception:
        return raw # If the XML is invalid, the text is returned as is

def _format_xml_documentation(root: ET.Element) -> str:
    """
    Formats a block of C# XML documentation and converts it into readable text 
    with a Markdown-like structure.

    The function receives an XML root node and extracts the most common documentation 
    sections, transforming them into a consistent and easy-to-render format.

    Args:
        root (Element[str]):
            Root node of the XML tree containing the C# documentation.

    Returns:
        str:
            Formatted and standardized text, ready to be included in Markdown documentation.
    """
    parts: List[str] = []

    summary = root.find('summary')
    if summary is not None:
        txts = _xml_node_to_text(summary).strip()

        if txts:
            parts.append(txts)
            parts.append('')

    params = root.findall('param')
    if params:
        parts.append('*Params:*')

        for param in params:
            name = param.attrib.get('name', '').strip()
            textp = _xml_node_to_text(param).strip()

            if name:
                parts.append(f'- {name}: {textp}')
            else:
                parts.append(f'- {textp}')

        parts.append('')

    returns = root.find('returns')
    if returns is not None:
        txtr = _xml_node_to_text(returns).strip()

        if txtr:
            parts.append('*Returns:*')
            parts.append(f'- {txtr.replace("- ", "")}')
            parts.append('')

    exceptions = root.findall('exception')
    if exceptions:
        parts.append('*Exceptions:*')

        for exception in exceptions:
            cref = exception.attrib.get('cref', '').strip().lstrip('T:') # Usually comes as T:Name
            texte = _xml_node_to_text(exception).strip()

            if cref:
                parts.append(f'- {cref}: {texte}')
            else:
                parts.append(f'- {texte}')

        parts.append('')

    # Cleaning: remove any excess blank lines at the end
    while parts and parts[-1] == '':
        parts.pop()

    return '\n'.join(parts)

def _xml_node_to_text(node: ET.Element) -> str:
    """
    Converts an XML documentation node into plain text.

    **Key features:**
        - Removes noise and unnecessary spaces.
        - Interprets `<see cref="X"/>` nodes, returning only "X".
        - Processes nested nodes while maintaining the natural order of the text.
        - Respects the content before, between, and after child nodes.

    Args:
        node (Element[str]):
            XML node to be transformed.

    Returns:
        str:
            Clean, readable text corresponding to the node's content.
    """
    parts: List[str] = []

    if node.text and node.text.strip():
        parts.append(node.text.strip())

    for child in node:
        if child.tag == 'see':
            cref = child.attrib.get('cref', '').strip()
            
            # Sometimes it comes as T:Namespace.Type
            if ':' in cref:
                cref = cref.split(':', 1)[-1]

            if cref:
                parts.append(cref)

        elif child.tag == 'paramref':
            name = child.attrib.get('name', '').strip()
            
            if name:
                parts.append(name)

        else:
            text_child = _xml_node_to_text(child)
            
            if text_child:
                parts.append(text_child)

        # Text following the daughter tag
        if child.tail and child.tail.strip():
            parts.append(child.tail.strip())

    return ' '.join(parts)

def _collect_decorators(lines: List[str], start_idx: int) -> List[str]:
    """
    Extracts C#-style decorators (attributes) applied to a class, method, constructor or field.

    The algorithm ascends from `start_idx`, collecting all immediately preceding documentation,
    sorting it, and then parsing it as valid XML.

    Args:
        lines (List[str]):
            The file content split into lines.
        start_idx (int):
            The 1-based index of the declaration line.

    Returns:
        List:
            List with all decorators found.
    """
    attrs: List[str] = []
    idx = start_idx - 1

    while idx >= 0:
        txt = lines[idx].rstrip()

        if txt.strip().startswith('[') and txt.strip().endswith(']'):
            attrs.append(txt.strip())
            idx -= 1
            continue

        if txt.strip().startswith('///'):
            idx -= 1
            continue

        break

    attrs.reverse()

    return attrs

def _collect_imports(src: str) -> List[str]:
    """
    Extracts declared namespaces and imported namespaces within a C# file.

    This function analyzes the entire contents of the source file using predefined 
    regular expressions and returns a homogeneous collection representing both the 
    file's own namespaces and external dependencies declared using `using`.

    Its purpose is to unify information related to dependency resolution at the module 
    level, leaving the file's own namespaces explicitly marked for later identification.

    Args:
        src(str):
            Complete contents of the C# file in text format.

    Returns:
        List:
            Ordered list, without duplicates, of all namespaces imported 
            using `using` statements.
    """
    src = src.lstrip('\ufeff')
    namespaces = sorted({item.group(1) for item in NAMESPACE_RE.finditer(src)})
    usings = sorted({item.group(1) for item in USING_RE.finditer(src)})

    imports: List[str] = []
    for ns in namespaces:
        imports.append(f'__ns__:{ns}')

    imports.extend(usings)

    return imports

# ---------------------------------------------------------------------------------------------------------------------
# END OF FILE