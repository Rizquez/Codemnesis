# MODULES (EXTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
import re
import logging
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Optional
# ---------------------------------------------------------------------------------------------------------------------

# MODULES (INTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
from src.models import *
from common.constants import ALGORITHM
from src.utils.metrics import module_metrics
# ---------------------------------------------------------------------------------------------------------------------

# MAIN PARSING REGEXES
# ---------------------------------------------------------------------------------------------------------------------
# IMPORTANT:
#   These regular expressions cover the most common cases of C# syntax, 
#   but they are not a substitute for a formal parser, if false positives 
#   or negatives appear in large projects, this is where you should adjust 
#   the logic

# Detects definitions of classes, interfaces, records, and structs
CLASS_RE = re.compile(
    r'^\s*(?:public|internal|protected|private)?\s*'
    r'(?:abstract|sealed|static|partial)?\s*'
    r'(class|record|struct|interface)\s+([A-Za-z_][A-Za-z0-9_]*)\b',
    re.MULTILINE
)

# Detects methods within the body of a class
METHOD_RE = re.compile(
    r'^\s*(?:public|private|protected|internal)\s*'
    r'(?:static\s+|virtual\s+|override\s+|async\s+|sealed\s+|partial\s+)*'
    r'[\w<>\[\],\s]+\s+([A-Za-z_][A-Za-z0-9_]*)\s*\([^)]*\)\s*{?',
    re.MULTILINE
)

# Detects attributes/properties
ATTRIBUTE_RE = re.compile(
    r'^\s*(?:public|private|protected|internal)\s*'
    r'(?:static\s+|readonly\s+|const\s+)?'
    r'[\w<>\[\],\s]+\s+([A-Za-z_][A-Za-z0-9_]*)\s*'
    r'(?:{[^}]*}|=>|=|;)',
    re.MULTILINE
)

# Detect using (includes global and alias)
USING_RE = re.compile(
    r'^\s*(?:global\s+)?using\s+(?:static\s+)?'
    r'(?:[A-Za-z_][A-Za-z0-9_]*\s*=\s*)?'
    r'([A-Za-z_][A-Za-z0-9_.]*)\s*;',
    re.MULTILINE
)

# Detect file namespace
NAMESPACE_RE = re.compile(
    r'^\s*namespace\s+([A-Za-z_][A-Za-z0-9_.]*)\s*(?:{|;)',
    re.MULTILINE
)
# ---------------------------------------------------------------------------------------------------------------------

# OPERATIONS / CLASS CREATION / GENERAL FUNCTIONS
# ---------------------------------------------------------------------------------------------------------------------

__all__ = ['analyze_csharp']

logger = logging.getLogger(ALGORITHM)
"""
Instance of the logger used by the analysis module.
"""

def analyze_csharp(path: Path, framework: str) -> ModuleInfo:
    """
    Analyzes a C# file, obtaining structural information: classes, methods, attributes, 
    XML documentation, and metrics.

    This parser does NOT use the C# compiler, but rather regular expressions + manual analysis. 
    
    **This means:**
        - Easier to maintain.
        - Faster.
        - But not perfect: if the syntax is very complex, there may be unsupported cases.

    **The most sensitive areas are:**
        1. CLASS_RE, METHOD_RE, ATTRIBUTE_RE → to improve detection.
        2. Key block delimitation → important to avoid false hits.
        3. XML docstring processing → to further enrich data extraction.

    Args:
        path (Path):
            Path of the C# file to be analyzed.
        framework (str):
            Name of the framework used, which must have a compatible mapping method.

    Returns:
        ModuleInfo:
            Object with all the structural and documentary information of the C# file.
    """
    src = path.read_text(encoding='utf-8', errors='ignore')
    src = src.lstrip('\ufeff') # Remove the BOM, which is common in files generated by Windows tools
    lines = src.splitlines()

    classes: List[ClassInfo] = []

    for cls_match in CLASS_RE.finditer(src):
        cls_name = cls_match.group(2)
        cls_lineno = src.count('\n', 0, cls_match.start()) + 1 # Exact line where the class begins
        cls_info = ClassInfo(
            name=cls_name, 
            lineno=cls_lineno, 
            doc=_collect_xml_text(lines, cls_lineno - 1), 
            decorators=_collect_decorators(lines, cls_lineno - 1)
        )

        # Search for the nearest { key after the declaration
        # This counter-based system works because C# uses well-defined curly braces
        # But it would fail if there were curly braces inside multi-line text literals (very rare)
        idx_brace = src.find('{', cls_match.end())
        if idx_brace == -1:
            kind = cls_match.group(1) # class, record, struct, interface
            logger.warning(f"Could not find '{{' for {kind} {cls_name} in {path.name} (Line {cls_lineno})")
            classes.append(cls_info)
            continue

        block = _extract_text_block(src, idx_brace)

        # It is compiled dynamically because the constructor name = class name
        CONSTRUCTOR_RE = re.compile(
            rf'^\s*(?:public|private|protected|internal)\s*'
            rf'(?:static\s+)?'
            rf'{re.escape(cls_name)}\s*\([^)]*\)\s*{{?',
            re.MULTILINE
        )

        for ctor in CONSTRUCTOR_RE.finditer(block):
            ctor_lineno = src.count('\n', 0, idx_brace + ctor.start()) + 1
            cls_info.methods.append(
                FunctionInfo(
                    name=cls_name, 
                    lineno=ctor_lineno, 
                    doc=_collect_xml_text(lines, ctor_lineno - 1)
                )
            )

        for method in METHOD_RE.finditer(block):
            method_lineno = src.count('\n', 0, idx_brace + method.start()) + 1
            cls_info.methods.append(
                FunctionInfo(
                    name=method.group(1),
                    lineno=method_lineno,
                    doc=_collect_xml_text(lines, method_lineno - 1),
                    decorators=_collect_decorators(lines, method_lineno - 1)
                )
            )

        for attr in ATTRIBUTE_RE.finditer(block):
            attr_lineno = src.count('\n', 0, idx_brace + attr.start()) + 1
            cls_info.attributes.append(
                AttributeInfo(
                    name=attr.group(1), 
                    lineno=attr_lineno, 
                    doc=_collect_xml_text(lines, attr_lineno - 1)
                )
            )

        classes.append(cls_info)

    return ModuleInfo(
        path=str(path),
        doc=None,           # C# does not have docstrings at the module level
        functions=[],       # C# does not have typical top-level functions
        classes=classes,
        imports=_collect_imports(src),
        metrics=module_metrics(src, classes, [], framework)
    )

def _extract_text_block(src: str, idx_brace: int) -> str:
    """
    Extracts a block of code delimited by curly braces `{ ... }` from a known starting position, 
    correctly ignoring curly braces that appear within comments or C# literals.

    This function is specifically designed for static analysis of C# code without using a formal 
    parser (Roslyn). It implements a sequential scanner with explicit states that partially simulates 
    the lexical behavior of the language.

    **The algorithm:**
        - Starts at the position of the opening `{` character.
        - Advances character by character, maintaining a curly brace depth counter.
        - Increments the depth only when it finds `{` outside of any literal or comment.
        - Decrements the depth only when it finds `}` outside of any literal or comment.
        - Ends when the depth returns to zero, indicating the correct closure of the block.
    
    **Known limitations:**
        - It is not a complete C# parser.

    Args:
        src (str):
            Complete content of the C# file in text format.
        idx_brace (int):
            Index (0-based) within src where the opening brace `{` of the block to be extracted is located.

    Returns:
        str:
            Substring of `src` representing the block delimited by braces, starting at `{` and ending just 
            before the corresponding closing `}`. If no valid closing brace is found, the text from `idx_brace` 
            to the end of the file is returned.
    """
    source_length = len(src)
    cursor = idx_brace
    brace_depth = 0

    # --- Comment states ---
    in_single_line_comment = False   # //
    in_multi_line_comment = False    # /* ... */

    # --- Literal states ---
    in_char_literal = False          # 'a'
    in_string_literal = False        # "..."
    in_verbatim_string = False       # @"..."
    escape_next_char = False         # \ in normal strings

    # --- Raw string state (C# 11+) ---
    in_raw_string = False
    raw_string_delimiter_length = 0  # Number of " characters (>= 3)

    while cursor < source_length:
        current_char = src[cursor]
        next_char = src[cursor + 1] if cursor + 1 < source_length else ''

        # ==========================================================
        # 1) Handle comment states
        # ==========================================================
        if in_single_line_comment:
            if current_char == '\n':
                in_single_line_comment = False
            cursor += 1
            continue

        if in_multi_line_comment:
            if current_char == '*' and next_char == '/':
                in_multi_line_comment = False
                cursor += 2
            else:
                cursor += 1
            continue

        # ==========================================================
        # 2) Handle raw string literals
        # ==========================================================
        if in_raw_string:
            if current_char == '"':
                lookahead = cursor
                while lookahead < source_length and src[lookahead] == '"':
                    lookahead += 1

                quote_run_length = lookahead - cursor

                if quote_run_length >= raw_string_delimiter_length:
                    in_raw_string = False
                    cursor += raw_string_delimiter_length
                    continue

                cursor = lookahead
                continue

            cursor += 1
            continue

        # ==========================================================
        # 3) Handle char literals
        # ==========================================================
        if in_char_literal:
            if escape_next_char:
                escape_next_char = False
                cursor += 1
                continue

            if current_char == '\\':
                escape_next_char = True
                cursor += 1
                continue

            if current_char == "'":
                in_char_literal = False

            cursor += 1
            continue

        # ==========================================================
        # 4) Handle normal / verbatim strings
        # ==========================================================
        if in_string_literal:
            if in_verbatim_string:
                if current_char == '"' and next_char == '"':
                    cursor += 2
                    continue

                if current_char == '"':
                    in_string_literal = False
                    in_verbatim_string = False
                    cursor += 1
                    continue

                cursor += 1
                continue

            # Normal string
            if escape_next_char:
                escape_next_char = False
                cursor += 1
                continue

            if current_char == '\\':
                escape_next_char = True
                cursor += 1
                continue

            if current_char == '"':
                in_string_literal = False
                cursor += 1
                continue

            cursor += 1
            continue

        # ==========================================================
        # 5) Detect comment entry
        # ==========================================================
        if current_char == '/' and next_char == '/':
            in_single_line_comment = True
            cursor += 2
            continue

        if current_char == '/' and next_char == '*':
            in_multi_line_comment = True
            cursor += 2
            continue

        # ==========================================================
        # 6) Detect char literal entry
        # ==========================================================
        if current_char == "'":
            in_char_literal = True
            escape_next_char = False
            cursor += 1
            continue

        # ==========================================================
        # 7) Detect raw string entry
        # ==========================================================
        # Case: """..."""
        if current_char == '"':
            lookahead = cursor
            while lookahead < source_length and src[lookahead] == '"':
                lookahead += 1

            quote_run_length = lookahead - cursor

            if quote_run_length >= 3:
                in_raw_string = True
                raw_string_delimiter_length = quote_run_length
                cursor = lookahead
                continue

            in_string_literal = True
            in_verbatim_string = False
            escape_next_char = False
            cursor += 1
            continue

        # Case: $"""...""" / $$"""..."""
        if current_char == '$':
            dollar_cursor = cursor
            while dollar_cursor < source_length and src[dollar_cursor] == '$':
                dollar_cursor += 1

            if dollar_cursor < source_length and src[dollar_cursor] == '"':
                quote_cursor = dollar_cursor
                while quote_cursor < source_length and src[quote_cursor] == '"':
                    quote_cursor += 1

                quote_run_length = quote_cursor - dollar_cursor

                if quote_run_length >= 3:
                    in_raw_string = True
                    raw_string_delimiter_length = quote_run_length
                    cursor = quote_cursor
                    continue

            cursor += 1
            continue

        # ==========================================================
        # 8) Detect string entry (@"...", $"...", $@"...", @$"...")
        # ==========================================================
        if current_char in ('@', '$'):
            if next_char == '"':
                in_string_literal = True
                in_verbatim_string = (current_char == '@')
                escape_next_char = False
                cursor += 2
                continue

            if (
                cursor + 2 < source_length
                and src[cursor + 1] in ('@', '$')
                and src[cursor + 2] == '"'
            ):
                in_string_literal = True
                in_verbatim_string = '@' in (src[cursor], src[cursor + 1])
                escape_next_char = False
                cursor += 3
                continue

        # ==========================================================
        # 9) Count braces (ONLY here)
        # ==========================================================
        if current_char == '{':
            brace_depth += 1
        elif current_char == '}':
            brace_depth -= 1
            if brace_depth == 0:
                return src[idx_brace:cursor]

        cursor += 1

    return src[idx_brace:]

def _collect_xml_text(lines: List[str], start_idx: int) -> Optional[str]:
    """
    Extracts, interprets, and converts XML documentation preceding a class or method.

    This type of documentation consists of lines beginning with `///`.

    The algorithm ascends from `start_idx`, collecting all immediately preceding documentation,
    sorting it, and then parsing it as valid XML.

    **The function:**
        - Detects `<summary>`
        - Detects `<param name="x">`
        - Detects `<returns>`
        - Detects `<exception cref="X">`
        - Converts `<see cref="X"/>` nodes to plain text (X)
        - Generates a structured block of readable text

    If the block is not valid XML or does not contain relevant tags, it is returned as is.

    **Notes:**
        - This method is delicate: the logic depends on the exact order of lines.
        - To extend and support more XML tags, it must be done here.

    Args:
        lines (List[str]):
            List of lines from the source file.
        start_idx (int):
            Index where the class or method appears, used to search documentation upwards.

    Returns:
        (str | None):
            Processed and cleaned text from the documentation, or None if there is no associated documentation.
    """
    idx = start_idx - 1
    buffer: List[str] = []

    # It ascends by collecting lines with C# XML format: /// ...
    while idx >= 0:
        txt = lines[idx].rstrip()

        # The 3 slashes are removed and the content is stored
        if txt.strip().startswith('///'):
            buffer.append(txt.strip().lstrip('/').strip())
            idx -= 1
            continue

        # Blank lines are allowed between documentation
        if txt.strip() == '':
            idx -= 1
            continue

        # If an attribute [Something] exists, the search continues upwards
        if txt.strip().startswith('[') and txt.strip().endswith(']'):
            idx -= 1
            continue

        break

    if not buffer:
        return None

    buffer.reverse()
    raw = '\n'.join(buffer)

    if not any(tag in raw for tag in ('<summary', '<param', '<returns', '<exception')):
        return raw

    # It is wrapped in a <root> to make it valid XML
    try:
        root = ET.fromstring(f'<root>\n{raw}\n</root>')
        return _format_xml_documentation(root)
    except Exception:
        return raw # If the XML is invalid, the text is returned as is

def _format_xml_documentation(root: ET.Element) -> str:
    """
    Formats a block of C# XML documentation and converts it into readable text 
    with a Markdown-like structure.

    The function receives an XML root node and extracts the most common documentation 
    sections, transforming them into a consistent and easy-to-render format.

    Args:
        root (Element[str]):
            Root node of the XML tree containing the C# documentation.

    Returns:
        str:
            Formatted and standardized text, ready to be included in Markdown documentation.
    """
    parts: List[str] = []

    summary = root.find('summary')
    if summary is not None:
        txts = _xml_node_to_text(summary).strip()

        if txts:
            parts.append(txts)
            parts.append('')

    params = root.findall('param')
    if params:
        parts.append('*Params:*')

        for param in params:
            name = param.attrib.get('name', '').strip()
            textp = _xml_node_to_text(param).strip()

            if name:
                parts.append(f'- {name}: {textp}')
            else:
                parts.append(f'- {textp}')

        parts.append('')

    returns = root.find('returns')
    if returns is not None:
        txtr = _xml_node_to_text(returns).strip()

        if txtr:
            parts.append('*Returns:*')
            parts.append(f'- {txtr.replace("- ", "")}')
            parts.append('')

    exceptions = root.findall('exception')
    if exceptions:
        parts.append('*Exceptions:*')

        for exception in exceptions:
            cref = exception.attrib.get('cref', '').strip().lstrip('T:') # Usually comes as T:Name
            texte = _xml_node_to_text(exception).strip()

            if cref:
                parts.append(f'- {cref}: {texte}')
            else:
                parts.append(f'- {texte}')

        parts.append('')

    # Cleaning: remove any excess blank lines at the end
    while parts and parts[-1] == '':
        parts.pop()

    return '\n'.join(parts)

def _xml_node_to_text(node: ET.Element) -> str:
    """
    Converts an XML documentation node into plain text.

    **Key features:**
        - Removes noise and unnecessary spaces.
        - Interprets `<see cref="X"/>` nodes, returning only "X".
        - Processes nested nodes while maintaining the natural order of the text.
        - Respects the content before, between, and after child nodes.

    Args:
        node (Element[str]):
            XML node to be transformed.

    Returns:
        str:
            Clean, readable text corresponding to the node's content.
    """
    parts: List[str] = []

    if node.text and node.text.strip():
        parts.append(node.text.strip())

    for child in node:
        if child.tag == 'see':
            cref = child.attrib.get('cref', '').strip()
            
            # Sometimes it comes as T:Namespace.Type
            if ':' in cref:
                cref = cref.split(':', 1)[-1]

            if cref:
                parts.append(cref)

        elif child.tag == 'paramref':
            name = child.attrib.get('name', '').strip()
            
            if name:
                parts.append(name)

        else:
            text_child = _xml_node_to_text(child)
            
            if text_child:
                parts.append(text_child)

        # Text following the daughter tag
        if child.tail and child.tail.strip():
            parts.append(child.tail.strip())

    return ' '.join(parts)

def _collect_decorators(lines: List[str], start_idx: int) -> List[str]:
    """
    Extracts C#-style decorators (attributes) applied to a class, method, constructor, or field.

    The function ascends from the line immediately preceding `start_idx`, collecting all contiguous 
    attribute declarations written in C# attribute syntax `[Attribute(...)]`.

    **During the upward scan:**
        - Attribute lines enclosed in brackets `[...]` are collected.
        - XML documentation lines starting with `///` are skipped.
        - The scan stops when a non-related line is found.

    Args:
        lines (List[str]):
            The file content split into lines.
        start_idx (int):
            Zero-based index of the declaration line; the search starts from the line above it.

    Returns:
        List:
            Ordered list of decorators found, preserving their original order.
    """
    attrs: List[str] = []
    idx = start_idx - 1

    while idx >= 0:
        txt = lines[idx].rstrip()

        if txt.strip().startswith('[') and txt.strip().endswith(']'):
            attrs.append(txt.strip())
            idx -= 1
            continue

        if txt.strip().startswith('///'):
            idx -= 1
            continue

        break

    attrs.reverse()

    return attrs

def _collect_imports(src: str) -> List[str]:
    """
    Extracts declared namespaces and imported namespaces within a C# file.

    This function analyzes the entire contents of the source file using predefined 
    regular expressions and returns a homogeneous collection representing both the 
    file's own namespaces and external dependencies declared using `using`.

    Its purpose is to unify information related to dependency resolution at the module 
    level, leaving the file's own namespaces explicitly marked for later identification.

    Args:
        src(str):
            Complete contents of the C# file in text format.

    Returns:
        List:
            Ordered list, without duplicates, of all namespaces imported 
            using `using` statements.
    """
    src = src.lstrip('\ufeff')
    namespaces = sorted({item.group(1) for item in NAMESPACE_RE.finditer(src)})
    usings = sorted({item.group(1) for item in USING_RE.finditer(src)})

    imports: List[str] = []
    for ns in namespaces:
        imports.append(f'__ns__:{ns}')

    imports.extend(usings)

    return imports

# ---------------------------------------------------------------------------------------------------------------------
# END OF FILE