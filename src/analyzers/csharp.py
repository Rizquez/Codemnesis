# MODULES (EXTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
import logging, re
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Optional
# ---------------------------------------------------------------------------------------------------------------------

# MODULES (INTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
from src.models import *
from common.constants import ALGORITHM
from src.utils.metrics import module_metrics
# ---------------------------------------------------------------------------------------------------------------------

# MAIN PARSING REGEXES
# ---------------------------------------------------------------------------------------------------------------------
# IMPORTANT:
#   These regular expressions cover the most common cases of C# syntax, 
#   but they are not a substitute for a formal parser, if false positives 
#   or negatives appear in large projects, this is where you should adjust 
#   the logic

# Detects definitions of classes, interfaces, records, and structs
CLASS_RE = re.compile(
    r'^\s*(?:public|internal|protected|private)?\s*'
    r'(?:abstract|sealed|static|partial)?\s*'
    r'(class|record|struct|interface)\s+([A-Za-z_][A-Za-z0-9_]*)\b',
    re.MULTILINE
)

# Detects methods within the body of a class
METHOD_RE = re.compile(
    r'^\s*(?:public|private|protected|internal)\s*'
    r'(?:static\s+|virtual\s+|override\s+|async\s+|sealed\s+|partial\s+)*'
    r'[\w<>\[\],\s]+\s+([A-Za-z_][A-Za-z0-9_]*)\s*\([^)]*\)\s*{?',
    re.MULTILINE
)

# Detects attributes/properties
ATTRIBUTE_RE = re.compile(
    r'^\s*(?:public|private|protected|internal)\s*'
    r'(?:static\s+|readonly\s+|const\s+)?'
    r'[\w<>\[\],\s]+\s+([A-Za-z_][A-Za-z0-9_]*)\s*'
    r'(?:{[^}]*}|=>|=|;)',
    re.MULTILINE
)

# Detect using (includes global and alias)
USING_RE = re.compile(
    r'^\s*(?:global\s+)?using\s+(?:static\s+)?'
    r'(?:[A-Za-z_][A-Za-z0-9_]*\s*=\s*)?'
    r'([A-Za-z_][A-Za-z0-9_.]*)\s*;',
    re.MULTILINE
)

# Detect file namespace
NAMESPACE_RE = re.compile(
    r'^\s*namespace\s+([A-Za-z_][A-Za-z0-9_.]*)\s*(?:{|;)',
    re.MULTILINE
)
# ---------------------------------------------------------------------------------------------------------------------

# OPERATIONS / CLASS CREATION / GENERAL FUNCTIONS
# ---------------------------------------------------------------------------------------------------------------------

__all__ = ['analyze_csharp']

logger = logging.getLogger(ALGORITHM)
"""
Instance of the logger used by the analysis module.
"""

def analyze_csharp(path: Path) -> ModuleInfo:
    """
    Analyzes a C# file, obtaining structural information: classes, methods, attributes, 
    XML documentation, and metrics.

    This parser does NOT use the C# compiler, but rather regular expressions + manual analysis. 
    
    This means:
        - Easier to maintain.
        - Faster.
        - But not perfect: if the syntax is very complex, there may be unsupported cases.

    The most sensitive areas are:
        1. CLASS_RE, METHOD_RE, ATTRIBUTE_RE → to improve detection.
        2. Key block delimitation → important to avoid false hits.
        3. XML docstring processing → to further enrich data extraction.

    Args:
        path (Path):
            Path of the C# file to be analyzed.

    Returns:
        ModuleInfo:
            Object with all the structural and documentary information of the C# file.
    """
    src = path.read_text(encoding='utf-8', errors='ignore')
    src = src.lstrip('\ufeff') # Remove the BOM, which is common in files generated by Windows tools
    lines = src.splitlines()

    classes: List[ClassInfo] = []

    for cls_match in CLASS_RE.finditer(src):
        kind = cls_match.group(1) # class, record, struct, interface
        cls_name = cls_match.group(2)
        
        # Exact line where the class begins
        cls_start = cls_match.start()
        cls_lineno = src.count("\n", 0, cls_start) + 1

        # Documentation and previous attributes (decorators)
        cls_doc = _collect_xml_text(lines, cls_lineno - 1)
        cls_decorators = _collect_decorators(lines, cls_lineno - 1)

        cls_info = ClassInfo(
            name=cls_name, 
            lineno=cls_lineno, 
            doc=cls_doc, 
            decorators=cls_decorators
        )

        # Search for the nearest { key after the declaration
        # This counter-based system works because C# uses well-defined curly braces
        # But it would fail if there were curly braces inside multi-line text literals (very rare)
        idx_brace = src.find('{', cls_match.end())
        if idx_brace == -1:
            logger.warning(f"Could not find '{{' for {kind} {cls_name} in {path.name} (Line {cls_lineno})")
            classes.append(cls_info)
            continue

        # Corresponding } key
        depth = 0
        idx = idx_brace
        idx_end = len(src)

        while idx < len(src):
            if src[idx] == '{':
                depth += 1
            elif src[idx] == '}':
                depth -= 1

                if depth == 0:
                    idx_end = idx
                    break
            else:
                pass
            
            idx += 1

        class_block = src[idx_brace:idx_end]

        # It is compiled dynamically because the constructor name = class name
        CTOR_RE = re.compile(
            rf'^\s*(?:public|private|protected|internal)\s*'
            rf'(?:static\s+)?'
            rf'{re.escape(cls_name)}\s*\([^)]*\)\s*{{?',
            re.MULTILINE
        )

        for ctor in CTOR_RE.finditer(class_block):
            ctor_abs_start = idx_brace + ctor.start()
            ctor_lineno = src.count('\n', 0, ctor_abs_start) + 1
            ctor_doc = _collect_xml_text(lines, ctor_lineno - 1)

            cls_info.methods.append(
                FunctionInfo(
                    name=cls_name, 
                    lineno=ctor_lineno, 
                    doc=ctor_doc
                )
            )

        for method in METHOD_RE.finditer(class_block):
            method_name = method.group(1)
            method_abs_start = idx_brace + method.start()
            method_lineno = src.count('\n', 0, method_abs_start) + 1
            method_doc = _collect_xml_text(lines, method_lineno - 1)
            method_decorators = _collect_decorators(lines, method_lineno - 1)

            cls_info.methods.append(
                FunctionInfo(
                    name=method_name,
                    lineno=method_lineno,
                    doc=method_doc,
                    decorators=method_decorators
                )
            )

        for attr in ATTRIBUTE_RE.finditer(class_block):
            attr_name = attr.group(1)
            attr_abs_start = idx_brace + attr.start()
            attr_lineno = src.count('\n', 0, attr_abs_start) + 1
            attr_doc = _collect_xml_text(lines, attr_lineno - 1)

            cls_info.attributes.append(
                AttributeInfo(
                    name=attr_name, 
                    lineno=attr_lineno, 
                    doc=attr_doc
                )
            )

        classes.append(cls_info)

    return ModuleInfo(
        path=str(path),
        doc=None,           # C# does not have docstrings at the module level
        functions=[],       # C# does not have typical top-level functions
        classes=classes,
        imports=_collect_imports(src),
        metrics=module_metrics(src, classes, [])
    )

def _collect_xml_text(lines: List[str], start_idx: int) -> Optional[str]:
    """
    Extracts, interprets, and converts XML documentation preceding a class or method.

    This type of documentation consists of lines beginning with `///`.

    The algorithm ascends from `start_idx`, collecting all immediately preceding documentation,
    sorting it, and then parsing it as valid XML.

    **The function:**
        - Detects `<summary>`
        - Detects `<param name="x">`
        - Detects `<returns>`
        - Detects `<exception cref="X">`
        - Converts `<see cref="X"/>` nodes to plain text (X)
        - Generates a structured block of readable text

    If the block is not valid XML or does not contain relevant tags, it is returned as is.

    **Notes:**
        - This method is delicate: the logic depends on the exact order of lines.
        - To extend and support more XML tags, it must be done here.

    Args:
        lines (List[str]):
            List of lines from the source file.

        start_idx (int):
            Index where the class or method appears, used to search documentation upwards.

    Returns:
        (str | None):
            Processed and cleaned text from the documentation, or None if there is no associated documentation.
    """
    idx = start_idx - 1
    buf: List[str] = []

    # It ascends by collecting lines with C# XML format: /// ...
    while idx >= 0:
        txt = lines[idx].rstrip()

        # The 3 slashes are removed and the content is stored
        if txt.strip().startswith('///'):
            buf.append(txt.strip().lstrip('/').strip())
            idx -= 1
            continue

        # Blank lines are allowed between documentation
        if txt.strip() == '':
            idx -= 1
            continue

        # If an attribute [Something] exists, the search continues upwards
        if txt.strip().startswith('[') and txt.strip().endswith(']'):
            idx -= 1
            continue

        break

    if not buf:
        return None

    buf.reverse()
    raw = '\n'.join(buf)

    if not any(tag in raw for tag in ('<summary', '<param', '<returns', '<exception')):
        return raw

    # It is wrapped in a <root> to make it valid XML
    xml_source = '<root>\n' + raw + '\n</root>'

    try:
        root = ET.fromstring(xml_source)
    except Exception:
        return raw # If the XML is invalid, the text is returned as is

    parts: List[str] = []

    summary = root.find('summary')
    if summary is not None:
        txts = _xml_node_to_text(summary).strip()

        if txts:
            parts.append(txts)
            parts.append('')

    params = root.findall('param')
    if params:
        parts.append('*Params:*')

        for param in params:
            name = param.attrib.get('name', '').strip()
            textp = _xml_node_to_text(param).strip()

            if name:
                parts.append(f'- {name}: {textp}')
            else:
                parts.append(f'- {textp}')

        parts.append('')

    returns = root.find('returns')
    if returns is not None:
        txtr = _xml_node_to_text(returns).strip()

        if txtr:
            txtr = txtr.replace('- ', '')
            parts.append('*Returns:*')
            parts.append(f'- {txtr}')
            parts.append('')

    exceptions = root.findall('exception')
    if exceptions:
        parts.append('*Exceptions:*')

        for exception in exceptions:
            cref = exception.attrib.get('cref', '').strip().lstrip('T:') # Usually comes as T:Name
            texte = _xml_node_to_text(exception).strip()

            if cref:
                parts.append(f'- {cref}: {texte}')
            else:
                parts.append(f'- {texte}')

        parts.append('')

    # Cleaning: remove any excess blank lines at the end
    while parts and parts[-1] == '':
        parts.pop()

    return '\n'.join(parts)

def _xml_node_to_text(node: ET.Element) -> str:
    """
    Converts an XML documentation node into plain text.

    **Key features:**
        - Removes noise and unnecessary spaces.
        - Interprets `<see cref="X"/>` nodes, returning only "X".
        - Processes nested nodes while maintaining the natural order of the text.
        - Respects the content before, between, and after child nodes.

    Args:
        node (Element[str]):
            XML node to be transformed.

    Returns:
        str:
            Clean, readable text corresponding to the node's content.
    """
    parts: List[str] = []

    if node.text and node.text.strip():
        parts.append(node.text.strip())

    for child in node:
        if child.tag == 'see':
            cref = child.attrib.get('cref', '').strip()
            
            # Sometimes it comes as T:Namespace.Type
            if ':' in cref:
                cref = cref.split(':', 1)[-1]

            if cref:
                parts.append(cref)
                
        elif child.tag == 'paramref':
            name = child.attrib.get('name', '').strip()
            
            if name:
                parts.append(name)

        else:
            text_child = _xml_node_to_text(child)
            
            if text_child:
                parts.append(text_child)

        # Text following the daughter tag
        if child.tail and child.tail.strip():
            parts.append(child.tail.strip())

    return ' '.join(parts)

def _collect_decorators(lines: List[str], start_idx: int) -> List[str]:
    """
    Extracts C#-style decorators (attributes) applied to a class, method, constructor or field.

    The algorithm ascends from `start_idx`, collecting all immediately preceding documentation,
    sorting it, and then parsing it as valid XML.

    Args:
        lines (List[str]):
            The file content split into lines.
        start_idx (int):
            The 1-based index of the declaration line.

    Returns:
        List:
            List with all decorators found.
    """
    attrs: List[str] = []
    idx = start_idx - 1

    while idx >= 0:
        txt = lines[idx].rstrip()

        if txt.strip().startswith('[') and txt.strip().endswith(']'):
            attrs.append(txt.strip())
            idx -= 1
            continue

        if txt.strip().startswith('///'):
            idx -= 1
            continue

        break

    attrs.reverse()

    return attrs

def _collect_imports(src: str) -> List[str]:
    """
    Extracts declared namespaces and imported namespaces within a C# file.

    This function analyzes the entire contents of the source file using predefined 
    regular expressions and returns a homogeneous collection representing both the 
    file's own namespaces and external dependencies declared using `using`.

    Its purpose is to unify information related to dependency resolution at the module 
    level, leaving the file's own namespaces explicitly marked for later identification.

    Args:
        src(str):
            Complete contents of the C# file in text format.

    Returns:
        List:
            Ordered list, without duplicates, of all namespaces imported 
            using `using` statements.
    """
    src = src.lstrip('\ufeff')

    namespaces = sorted({item.group(1) for item in NAMESPACE_RE.finditer(src)})
    usings = sorted({item.group(1) for item in USING_RE.finditer(src)})

    imports: List[str] = []
    for ns in namespaces:
        imports.append(f'__ns__:{ns}')

    imports.extend(usings)

    return imports

# ---------------------------------------------------------------------------------------------------------------------
# END OF FILE