# MODULES (EXTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
from __future__ import annotations

from pathlib import Path
from graphviz import Digraph
from typing import List, Dict, Set
# ---------------------------------------------------------------------------------------------------------------------

# MODULES (INTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
from src.utils.maps import identifiers_map
from common.constants import ALGORITHM_VERSION
# ---------------------------------------------------------------------------------------------------------------------

# OPERATIONS / CLASS CREATION / GENERAL FUNCTIONS
# ---------------------------------------------------------------------------------------------------------------------

FILE = 'Graphic'

CLUSTER_BG = "#f5f5f5"
NODE_FILL = "#ffffff"
NODE_BORDER = "#aaaaaa"
EDGE_INTRA = "#444444"
EDGE_INTER = "#1f77b4"

def dependency_diagram(repository: str, dep_map: Dict[str, Set[str]], format: str) -> Digraph:
    """
    Construct a repository dependency diagram using Graphviz.

    Starting with a dependency map between modules, this function generates a directed graph where:
        - Each node represents a module (file) in the repository.
        - Nodes are grouped into clusters based on their parent folder.
        - Each folder is drawn as a rectangle (cluster) with its name as the label.
        - Edges indicate dependencies between modules.
        - Edges within the same cluster use the color `EDGE_INTRA`.
        - Edges between clusters use the color `EDGE_INTER`.
        - An invisible `wrapper` cluster is created for each folder to increase the visual separation 
        between groups of modules.

    Additionally, a header is added with the algorithm version and the name of the analyzed repository.

    Args:
        repository (str):
            Base path of the repository or project to be analyzed.
        dep_map(Dict[str, Set[str]]): 
            Dictionary where each key is a module and its value is a set of modules on which 
            it depends.
        format (str): 
            Output format supported by Graphviz.

    Returns:
        Digraph: 
            Graphviz object ready to be rendered in the specified format.
    """
    title = f'Dependency diagram generated by Codemnesis - v.{ALGORITHM_VERSION}\n\n'
    subtitle = f'Repository analyzed: {Path(repository).resolve().name}'
    
    dot = Digraph(
        format=format,
        graph_attr={
            'rankdir': 'LR',
            'splines': 'ortho',
            'concentrate': 'true',
            'label': f'{title}{subtitle}',
            'labelloc': 't',
            'fontsize': '62',
            'pad': '1.5',
            'nodesep': '1.5'
        },
        node_attr={ # Default style of nodes
            'shape': 'ellipse',
            'style': 'filled',
            'fillcolor': NODE_FILL,
            'color': NODE_BORDER,
            'fontsize': '44'
        }
    )

    all_path = _module_paths(dep_map)

    # Internal map that associates each module path with a short, unique identifier
    # This avoids problems with long paths and ensures valid IDs for Graphviz
    id_map = identifiers_map(all_path)

    groups: Dict[str, List[str]] = {}
    for path in all_path:
        name = Path(path).parent.name or 'root'
        groups.setdefault(name, []).append(path)

    # For each folder (group), two subgraphs are created:
    #   outer: invisible wrapper that helps space clusters
    #   inner: actual cluster with colored background and folder label
    for name, paths in groups.items():
        outer = Digraph(name=f'cluster_wrap_{name.lower()}')
        outer.attr(
            style='invis',
            color='none',
            peripheries='0'
        )

        inner = Digraph(name=f'cluster_{name.lower()}')
        inner.attr(
            label=name,
            style='rounded,filled',
            color=CLUSTER_BG,
            fillcolor=CLUSTER_BG,
            fontsize='48'
        )

        # Creation of nodes within the cluster
        for path in paths:
            inner.node(id_map[path], Path(path).stem)

        outer.subgraph(inner)
        dot.subgraph(outer)

    # Creation of dependency edges between modules
    for src, targets in dep_map.items():
        src_name = Path(src).parent.name or 'root'
        src_id = id_map[src]

        for dest in targets:
            dest_name = Path(dest).parent.name or 'root'
            dest_id = id_map[dest]

            same_group = (src_name == dest_name)
            dot.edge(src_id, dest_id, color=EDGE_INTER if same_group else EDGE_INTRA)

    return dot

def _module_paths(dep_map: Dict[str, Set[str]]) -> List[str]:
    """
    This function retrieves the complete list of module paths present in the dependency map.

    **It extracts:**
        - All keys from the dictionary (source modules).
        - All valuesâ€‹ for each key (target modules).

    Then it combines both sets, removes duplicates, and returns them sorted.

    Args:
        dep_map(Dict[str, Set[str]]): 
            Dictionary where each key is a module and its value is a set of modules on which 
            it depends.

    Returns:
        List: 
            Alphabetically ordered list with all the unique paths detected.
    """
    all_path = list(dep_map.keys())

    # All modules that appear only as destinations must be added
    for path in dep_map.values():
        all_path.extend(list(path))

    return sorted(set(all_path))

# ---------------------------------------------------------------------------------------------------------------------
# END OF FILE