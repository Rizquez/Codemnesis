# MODULES (EXTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
import re
from pathlib import Path
from graphviz import Digraph
from typing import List, Dict, Set
# ---------------------------------------------------------------------------------------------------------------------

# MODULES (INTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
from src.utils.maps import identifiers_map
from common.constants import ALGORITHM_VERSION
# ---------------------------------------------------------------------------------------------------------------------

# OPERATIONS / CLASS CREATION / GENERAL FUNCTIONS
# ---------------------------------------------------------------------------------------------------------------------

CLUSTER_BG = '#f5f5f5'
NODE_FILL = '#ffffff'
NODE_BORDER = '#aaaaaa'
EDGE_INTRA = '#1f77b4'
EDGE_INTER = '#444444'

def dependency_diagram(repository: str, dep_map: Dict[str, Set[str]], file_format: str) -> Digraph:
    """
    Construct a repository dependency diagram using Graphviz.

    Starting with a dependency map between modules, this function generates a directed graph where:
        - Each node represents a module (file) in the repository.
        - Nodes are grouped into clusters based on their parent folder.
        - Each folder is drawn as a rectangle (cluster) with its name as the label.
        - Edges indicate dependencies between modules.
        - Edges within the same cluster use the color `EDGE_INTRA`.
        - Edges between clusters use the color `EDGE_INTER`.
        - An invisible `wrapper` cluster is created for each folder to increase the visual separation 
        between groups of modules.

    Additionally, a header is added with the algorithm version and the name of the analyzed repository.

    Args:
        repository (str):
            Base path of the repository or project to be analyzed.
        dep_map(Dict[str, Set[str]]): 
            Dictionary where each key is a module and its value is a set of modules on which 
            it depends.
        file_format (str): 
            Output format supported by Graphviz.

    Returns:
        Digraph: 
            Graphviz object ready to be rendered in the specified format.
    """
    title = f'Dependency diagram generated by Codemnesis - v.{ALGORITHM_VERSION}'
    subtitle = f'Repository analyzed: {Path(repository).resolve().name}'
    
    dot = Digraph(
        format=file_format,
        graph_attr={
            'rankdir': 'LR',
            'splines': 'ortho',
            'concentrate': 'true',
            'label': f'{title}\n\n{subtitle}',
            'labelloc': 't',
            'fontsize': '62',
            'pad': '1.5',
            'nodesep': '1.5'
        },
        node_attr={
            'shape': 'ellipse',
            'style': 'filled',
            'fillcolor': NODE_FILL,
            'color': NODE_BORDER,
            'fontsize': '44'
        }
    )

    all_path = _module_paths(dep_map)

    # Internal map that associates each module path with a short, unique identifier
    # This avoids problems with long paths and ensures valid IDs for Graphviz
    id_map = identifiers_map(all_path)

    root = Path(repository).resolve()
    groups: Dict[str, List[str]] = {}
    for path in all_path:
        parent = Path(path).resolve().parent
        relative = parent.relative_to(root)
        group_key = relative.as_posix() if str(relative) != '.' else 'root'
        groups.setdefault(group_key, []).append(path)

    # For each folder (group), two subgraphs are created:
    #   outer: invisible wrapper that helps space clusters
    #   inner: actual cluster with colored background and folder label
    for group_key, paths in groups.items():
        cluster_id = _sanitize_id(group_key)

        outer = Digraph(name=f'cluster_wrap_{cluster_id}')
        outer.attr(
            style='invis',
            color='none',
            peripheries='0'
        )

        inner = Digraph(name=f'cluster_{cluster_id}')
        inner.attr(
            label=group_key,
            style='rounded,filled',
            color=CLUSTER_BG,
            fillcolor=CLUSTER_BG,
            fontsize='48',
            margin='50'
        )

        # Creation of nodes within the cluster
        for path in paths:
            inner.node(id_map[path], Path(path).stem)

        outer.subgraph(inner)
        dot.subgraph(outer)

    # Creation of dependency edges between modules
    for src, targets in dep_map.items():
        src_parent = Path(src).resolve().parent
        src_relative = src_parent.relative_to(root)
        src_group = src_relative.as_posix() if str(src_relative) != '.' else 'root'
        src_id = id_map[src]

        for dest in targets:
            dest_parent = Path(dest).resolve().parent
            dest_relative = dest_parent.relative_to(root)
            dest_group = dest_relative.as_posix() if str(dest_relative) != '.' else 'root'
            dest_id = id_map[dest]

            same_group = (src_group == dest_group)
            dot.edge(src_id, dest_id, color=EDGE_INTRA if same_group else EDGE_INTER)

    return dot

def _module_paths(dep_map: Dict[str, Set[str]]) -> List[str]:
    """
    This function retrieves the complete list of module paths present in the dependency map.

    **It extracts:**
        - All keys from the dictionary (source modules).
        - All valuesâ€‹ for each key (target modules).

    Then it combines both sets, removes duplicates, and returns them sorted.

    Args:
        dep_map(Dict[str, Set[str]]): 
            Dictionary where each key is a module and its value is a set of modules on which 
            it depends.

    Returns:
        List: 
            Alphabetically ordered list with all the unique paths detected.
    """
    all_path = list(dep_map.keys())

    # All modules that appear only as destinations must be added
    for path in dep_map.values():
        all_path.extend(list(path))

    return sorted(set(all_path))

def _sanitize_id(text: str) -> str:
    """
    Converts a text string into a safe identifier for Graphviz.

    This function transforms the received text into a valid identifier by removing or replacing 
    characters that can cause conflicts in Graphviz, such as slashes, dots, spaces, or other special 
    symbols.

    **Process applied:**
        - Converts all text to lowercase.
        - Replaces any character that is not alphanumeric or an underscore with `_`.
        - Removes extra underscores at the beginning and end.
        - Returns `root` if the result is empty.

    Args:
        text (str):
            Original text to be sanitized (usually a path or logical name).

    Returns:
        str:
            Normalized identifier compatible with Graphviz.
    """
    return re.sub(r'[^a-z0-9_]+', '_', text.lower()).strip('_') or 'root'

# ---------------------------------------------------------------------------------------------------------------------
# END OF FILE