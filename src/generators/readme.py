# MODULES (EXTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
from pathlib import Path
from typing import List, TYPE_CHECKING
# ---------------------------------------------------------------------------------------------------------------------

# MODULES (INTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
if TYPE_CHECKING:
    from src.analyzers.python import ModuleInfo
# ---------------------------------------------------------------------------------------------------------------------

# OPERATIONS / CLASS CREATION / GENERAL FUNCTIONS
# ---------------------------------------------------------------------------------------------------------------------

README_FILE = 'AutoDocMind.md'

class ReadmeHanler:
    """
    Utility for building and persisting project documentation in README format.

    This class concentrates **presentation** (Markdown formatting) and **output** (writing to disk) operations 
    based on the structured results produced by the code analyzer (`ModuleInfo`). It does not perform static analysis: 
    it only transforms already processed data into a readable document.
    """

    def render(modules: List['ModuleInfo'], directory: str) -> str:
        """
        Generates the contents of the README file from the information analyzed from the project modules.

        It scans the results obtained by the code analyzer (`ModuleInfo`) and builds a document in Markdown format
        that includes the repository description, the list of modules, their classes, methods, and functions, along 
        with the associated docstrings when available.

        Args:
            modules (List[ModuleInfo]):
                List of `ModuleInfo` objects representing the analyzed modules in the repository.
            directory (str):
                Base path of the analyzed repository. It is displayed in the header of the generated README.

        Returns:
            str:
                Text string with the complete content of the README formatted in Markdown.
        """
        lines = []
        
        lines.append("# ðŸ“˜ Documentation generated by AutoDocMind\n")
        lines.append(f"_Repository analyzed_: `{Path(directory).resolve()}`\n")
        lines.append("---\n")

        for module in sorted(modules, key=lambda module: module.path):
            lines.append(f"## ðŸ§© Module: `{str(Path(module.path).resolve())}`\n")

            if module.doc:
                lines.append(f"> {module.doc}\n")

            if module.classes:
                lines.append("### Clases\n")

                for cls in module.classes:
                    lines.append(f"- **{cls.name}** (L{cls.lineno})" + (f": {cls.doc}" if cls.doc else ""))

                    for meth in cls.methods:
                        lines.append(f"  - `{meth.name}()` (L{meth.lineno})" + (f": {meth.doc}" if meth.doc else ""))

            if module.functions:
                lines.append("### Funciones\n")

                for func in module.functions:
                    lines.append(f"- `{func.name}()` (L{func.lineno})" + (f": {func.doc}" if func.doc else ""))

            lines.append("")

        return "\n".join(lines)


    def write(text: str, output: str) -> Path:
        """
        Write the generated README content to the file system.

        Create the output directory if it does not exist and save the received text to a Markdown.

        Args:
            text (str):
                README content in Markdown format, usually generated by `render_readme`.
            output (str):
                Path of the directory where the file will be stored. If it does not exist, 
                it is created automatically.

        Returns:
            Path:
                Full path of the generated README file.
        """
        out = Path(output)
        out.mkdir(parents=True, exist_ok=True)

        target = out / README_FILE

        target.write_text(text, encoding="utf-8")

        return target

# ---------------------------------------------------------------------------------------------------------------------
# END OF FILE