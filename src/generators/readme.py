# MODULES (EXTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
from pathlib import Path
from typing import List, TYPE_CHECKING
# ---------------------------------------------------------------------------------------------------------------------

# MODULES (INTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
from settings.constants import ALGORITHM_VERSION
from src.utils.strings import DocStrings

if TYPE_CHECKING:
    from src.models.structures import ModuleInfo
# ---------------------------------------------------------------------------------------------------------------------

# OPERATIONS / CLASS CREATION / GENERAL FUNCTIONS
# ---------------------------------------------------------------------------------------------------------------------

__all__ = ['ReadmeGenerator']

README_FILE = 'README.md'

class ReadmeGenerator:
    """
    Utility for building and persisting project documentation in README format.

    This class concentrates **presentation** (Markdown formatting) and **output** (writing to disk) operations 
    based on the structured results produced by the code analyzer (`ModuleInfo`). It does not perform static analysis: 
    it only transforms already processed data into a readable document.
    """

    @staticmethod
    def render(modules: List['ModuleInfo'], directory: str, *, cleaned: List[str] = ['`']) -> str:
        """
        Generates the contents of the README file from the information analyzed from the project modules.

        It scans the results obtained by the code analyzer (`ModuleInfo`) and builds a document in Markdown format
        that includes the repository description, the list of modules, their classes, methods, and functions, along 
        with the associated docstrings when available.

        Args:
            modules (List[ModuleInfo]):
                List of `ModuleInfo` objects representing the analyzed modules in the repository.
            directory (str):
                Base path of the analyzed repository. It is displayed in the header of the generated README.
            cleaned (List[str]):
                List of tokens to be removed from the readme.

        Returns:
            str:
                Text string with the complete content of the README formatted in Markdown.
        """
        lines = []
        
        lines.append(f'# ðŸ“‘ Documentation generated by AutoDocMind - v.{ALGORITHM_VERSION}\n')
        lines.append(f'## ðŸ—ƒï¸ *Repository analyzed*: `{Path(directory).resolve().name}`\n')

        for module in sorted(modules, key=lambda module: module.path):
            relative = Path(module.path).resolve().relative_to(Path(directory).resolve())
            lines.append(f'## ðŸ—‚ï¸ Module: `{relative.as_posix()}`\n')

            if not module.classes and not module.functions:
                lines.append('*This module does not contain documentation on classes or functions.*\n')
            else:
                if module.classes:
                    for clss in module.classes:
                        if clss.doc:
                            lines.append(
                                f'### ðŸ“œ Class: `{clss.name}`\n'
                                f'{DocStrings.to_readme(clss.doc, cleaned=cleaned, tabulation=False)}\n'
                            )
                        else:
                            lines.append(
                                f'### ðŸ“œ Class: `{clss.name}` - '
                                '*This class does not contain documentation or it has not been possible to extract it.*\n'
                            )

                        for attr in clss.attributes:
                            if attr.doc:
                                lines.append(
                                    f'#### ðŸ“Œ *Attribute declared in line {attr.lineno}*: `{attr.name}` \n'
                                    f'{DocStrings.to_readme(attr.doc, cleaned=cleaned, tabulation=False)}\n'
                                )
                            else:
                                lines.append(
                                    f'#### ðŸ“Œ *Attribute declared in line {attr.lineno}*: `{attr.name}` - '
                                    '*This attribute does not contain documentation or it has not been possible to extract it.*\n'
                                )

                        for meth in clss.methods:
                            if meth.doc:
                                lines.append(
                                    f'#### ðŸ› ï¸ *Method declared in line {meth.lineno}*: `{meth.name}`\n'
                                    f'{DocStrings.to_readme(meth.doc, cleaned=cleaned, tabulation=False)}\n'
                                )
                            else:
                                lines.append(
                                    f'#### ðŸ› ï¸ *Method declared in line {meth.lineno}*: `{meth.name}` - '
                                    '*This method does not contain documentation or it has not been possible to extract it.*\n'
                                )

                if module.functions:
                    lines.append('### ðŸ“ƒ Functions\n')

                    for func in module.functions:
                        if func.doc:
                            lines.append(
                                
                                f'#### ðŸ› ï¸ *Function declared in line {func.lineno}*: `{func.name}`\n'
                                f'{DocStrings.to_readme(func.doc, cleaned=cleaned, tabulation=False)}\n'
                            )
                        else:
                            lines.append(
                                f'#### ðŸ› ï¸ *Function declared in line {func.lineno}*: `{func.name}` - '
                                '*This function does not contain documentation or it has not been possible to extract it.*\n'
                            )

        return '\n'.join(lines)

    @staticmethod
    def write(text: str, output: str) -> Path:
        """
        Write the generated README content to the file system.

        Create the output directory if it does not exist and save the received text to a Markdown.

        Args:
            text (str):
                README content in Markdown format, usually generated by `render_readme`.
            output (str):
                Path of the directory where the file will be stored. If it does not exist, 
                it is created automatically.

        Returns:
            Path:
                Full path of the generated README file.
        """
        out = Path(output)
        out.mkdir(parents=True, exist_ok=True)

        target = out / README_FILE

        target.write_text(text, encoding='utf-8')

        return target
    
# ---------------------------------------------------------------------------------------------------------------------
# END OF FILE