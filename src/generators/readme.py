# MODULES (EXTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
from pathlib import Path
from typing import List, TYPE_CHECKING
# ---------------------------------------------------------------------------------------------------------------------

# MODULES (INTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
from src.tools.docstring import format_docstring
from configuration.constants import ALGORITHM_VERSION, NO_METHOD, NO_FUNCTION, NO_CLASS, NO_MODULE, NO_ATTRIBUTE

if TYPE_CHECKING:
    from src.models import ModuleInfo
# ---------------------------------------------------------------------------------------------------------------------

# OPERATIONS / CLASS CREATION / GENERAL FUNCTIONS
# ---------------------------------------------------------------------------------------------------------------------

__all__ = ['render_readme', 'write_readme']

FILE = 'README.md'

def render_readme(modules: List['ModuleInfo'], repository: str, *, cleaned: List[str] = ['`']) -> str:
    """
    Generates the contents of the README file from the information analyzed from the project modules.

    It scans the results obtained by the code analyzer (`ModuleInfo`) and builds a document in Markdown format
    that includes the repository description, the list of modules, their classes, methods, and functions, along 
    with the associated docstrings when available.

    Args:
        modules (List[ModuleInfo]):
            List of `ModuleInfo` objects representing the analyzed modules in the repository.
        repository (str):
            Base path of the repository or project to be analyzed.
        cleaned (List[str]):
            List of tokens to be removed from the readme.

    Returns:
        str:
            Text string with the complete content of the README formatted in Markdown.
    """
    lines: List[str] = []
    
    lines.append(f'# ðŸ“‘ Documentation generated by AutoDocMind - v.{ALGORITHM_VERSION}\n')
    lines.append(f'## ðŸ—ƒï¸ *Repository analyzed*: `{Path(repository).resolve().name}`\n')

    for module in sorted(modules, key=lambda module: module.path):
        relative = Path(module.path).resolve().relative_to(Path(repository).resolve())
        lines.append(f'## ðŸ—‚ï¸ Module: `{relative.as_posix()}`\n')

        if module.metrics:
            lines.append('### ðŸ“Š Basic module metrics')
            lines.append(f'- Total classes: {module.metrics.n_classes}')
            lines.append(f'- Total methods: {module.metrics.n_methods}')
            lines.append(f'- Total functions: {module.metrics.n_functions}')
            lines.append(f'- Total lines of the module: {module.metrics.loc}')
            lines.append(f'- Total useful lines of the module: {module.metrics.sloc}\n')

        if not module.classes and not module.functions:
            lines.append(f'*{NO_MODULE}*\n')
        else:
            if module.classes:
                for clss in module.classes:
                    if clss.doc:
                        lines.append(
                            f'### ðŸ“œ Class: `{clss.name}`\n'
                            f'{format_docstring(clss.doc, cleaned=cleaned)}\n'
                        )
                    else:
                        lines.append(f'### ðŸ“œ Class: `{clss.name}` - *{NO_CLASS}*\n')

                    if clss.decorators:
                        decorators = "\n- ".join(clss.decorators)
                        lines.append(f'*Decorators:*\n- {decorators}\n')

                    for attr in clss.attributes:
                        if attr.doc:
                            lines.append(
                                f'#### ðŸ“Œ *Attribute declared in line {attr.lineno}*: `{attr.name}`\n'
                                f'{format_docstring(attr.doc, cleaned=cleaned)}\n'
                            )
                        else:
                            lines.append(
                                f'#### ðŸ“Œ *Attribute declared in line {attr.lineno}*: `{attr.name}` - '
                                f'*{NO_ATTRIBUTE}*\n'
                            )

                    for meth in clss.methods:
                        if meth.doc:
                            lines.append(
                                f'#### ðŸ› ï¸ *Method declared in line {meth.lineno}*: `{meth.name}`\n'
                                f'{format_docstring(meth.doc, cleaned=cleaned)}\n'
                            )
                        else:
                            lines.append(
                                f'#### ðŸ› ï¸ *Method declared in line {meth.lineno}*: `{meth.name}` - '
                                f'*{NO_METHOD}*\n'
                            )
                        
                        if meth.decorators:
                            decorators = "\n- ".join(meth.decorators)
                            lines.append(f'*Decorators:*\n- {decorators}\n')

            if module.functions:
                lines.append('### ðŸ“ƒ Functions\n')

                for func in module.functions:
                    if func.doc:
                        lines.append(
                            
                            f'#### ðŸ› ï¸ *Function declared in line {func.lineno}*: `{func.name}`\n'
                            f'{format_docstring(func.doc, cleaned=cleaned)}\n'
                        )
                    else:
                        lines.append(
                            f'#### ðŸ› ï¸ *Function declared in line {func.lineno}*: `{func.name}` - '
                            f'*{NO_FUNCTION}*\n'
                        )

    return '\n'.join(lines)

def write_readme(text: str, output: str) -> Path:
    """
    Write the generated README content to the file system.

    Create the output directory if it does not exist and save the received text to a Markdown.

    Args:
        text (str):
            README content in Markdown format, usually generated by `render_readme`.
        output (str):
            Path of the directory where the file will be stored. If it does not exist, 
            it is created automatically.

    Returns:
        Path:
            Full path of the generated README file.
    """
    out = Path(output)
    out.mkdir(parents=True, exist_ok=True)

    target = out / FILE

    target.write_text(text, encoding='utf-8')

    return target
    
# ---------------------------------------------------------------------------------------------------------------------
# END OF FILE