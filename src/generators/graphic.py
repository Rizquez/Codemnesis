# MODULES (EXTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
from pathlib import Path
from graphviz import Digraph
from typing import List, Dict, Set
from typing import TYPE_CHECKING, List, Dict, Set
# ---------------------------------------------------------------------------------------------------------------------

# MODULES (INTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
from src.utils.paths import dependencies_path
from configuration.constants import ALGORITHM_VERSION
from src.utils.maps import dependencies_map, identifiers_map

if TYPE_CHECKING:
    from src.models import ModuleInfo
# ---------------------------------------------------------------------------------------------------------------------

# OPERATIONS / CLASS CREATION / GENERAL FUNCTIONS
# ---------------------------------------------------------------------------------------------------------------------

__all__ = ['render_graphic']

FILE = 'Graphic'

CLUSTER_BG   = "#f5f5f5"
NODE_FILL    = "#ffffff"
NODE_BORDER  = "#aaaaaa"
EDGE_INTRA   = "#444444"
EDGE_INTER   = "#1f77b4"

def render_graphic(
    modules: List['ModuleInfo'], 
    output: str, 
    repository: str, 
    framework: str, 
    *, 
    format: str = 'svg'
) -> str:
    """
    Generates the dependency graph found between the analyzed modules.

    This method builds the internal dependency map of the code, invokes the generation of the corresponding graph, 
    and physically stores it in the user-defined path. The graph is generated according to the type of framework 
    evaluated, since each framework requires a different analysis of how the modules are structured.

    Args:
        modules (List[ModuleInfo]):
            List of `ModuleInfo` objects representing the analyzed modules in the repository.
        output (str):
            Path of the directory where the file will be stored. If it does not exist, it is created automatically.
        repository (str):
            Base path of the repository or project to be analyzed.
        framework (str):
            Name of the framework used, which must have a compatible mapping method.
        format (str, optional):
            Final format of the graph file.
    
    Returns:
        str:
            Absolute path of the generated output file.
    """
    dep_map: Dict[str, Set] = dependencies_map(modules, repository, framework)

    graph = _map_to_graphic(repository, dep_map, format)

    out = Path(output) / f'{FILE}.{format}'

    graph.render(out.with_suffix(''), cleanup=True)

    return out

def _map_to_graphic(repository: str, dep_map: Dict[str, Set[str]], format: str) -> Digraph:
    """
    Construct a repository dependency diagram using Graphviz.

    Starting with a dependency map between modules, this function generates a directed graph where:
        - Each node represents a module (file) in the repository.
        - Nodes are grouped into clusters based on their parent folder.
        - Each folder is drawn as a rectangle (cluster) with its name as the label.
        - Edges indicate dependencies between modules.
        - Edges within the same cluster use the color `EDGE_INTRA`.
        - Edges between clusters use the color `EDGE_INTER`.
        - An invisible `wrapper` cluster is created for each folder to increase the visual separation 
        between groups of modules.

    Additionally, a header is added with the algorithm version and the name of the analyzed repository.

    Args:
        repository (str):
            Base path of the repository or project to be analyzed.
        dep_map(Dict[str, Set[str]]): 
            Dictionary where each key is a module and its value is a set of modules on which 
            it depends.
        format (str): 
            Output format supported by Graphviz.

    Returns:
        Digraph: 
            Graphviz object ready to be rendered in the specified format.
    """
    title = f'''
    Dependency diagram generated by AutoDocMind - v.{ALGORITHM_VERSION}
    \nRepository analyzed: {Path(repository).resolve().name}
    '''
    
    dot = Digraph(format=format)

    dot.attr(
        rankdir='LR',
        splines='ortho',
        concentrate='true',
        label=title,
        labelloc='t',
        fontsize='62',
        pad='1.5',
        nodesep='1.5'
    )

    dot.attr(
        'node',
        shape='ellipse',
        style='filled',
        fillcolor=NODE_FILL,
        color=NODE_BORDER,
        fontsize='44'
    )

    all_path = dependencies_path(dep_map)

    id_map = identifiers_map(all_path)

    groups: Dict[str, List[str]] = {}
    for path in all_path:
        name = Path(path).parent.name or 'root'
        groups.setdefault(name, []).append(path)

    for name, paths in groups.items():
        outer = Digraph(name=f'cluster_wrap_{name.lower()}')
        outer.attr(
            style='invis',
            color='none',
            peripheries='0'
        )

        inner = Digraph(name=f'cluster_{name.lower()}')
        inner.attr(
            label=name,
            style='rounded,filled',
            color=CLUSTER_BG,
            fillcolor=CLUSTER_BG,
            fontsize='48'
        )

        for path in paths:
            inner.node(
                id_map[path],
                _short_label(path)
            )

        outer.subgraph(inner)
        dot.subgraph(outer)

    for src, targets in dep_map.items():
        src_name = Path(src).parent.name or 'root'
        src_id = id_map[src]

        for dst in targets:
            dst_name = Path(dst).parent.name or 'root'
            dst_id = id_map[dst]

            if src_name != dst_name:
                dot.edge(src_id, dst_id, color=EDGE_INTRA)
            else:
                dot.edge(src_id, dst_id, color=EDGE_INTER)

    return dot

def _short_label(path: str) -> str:
    """
    Generates a short, readable label to represent a module in the diagram.

    Given a full path, it returns only the filename without the extension.

    Args:
        path (str): 
            Path or filename.

    Returns:
        str: 
            Base filename without extension.
    """
    return Path(path).stem

# ---------------------------------------------------------------------------------------------------------------------
# END OF FILE