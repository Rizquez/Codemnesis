# MODULES (EXTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
from __future__ import annotations
from pathlib import Path
from graphviz import Digraph
from typing import List, Dict, Set, TYPE_CHECKING
# ---------------------------------------------------------------------------------------------------------------------

# MODULES (INTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
from common.constants import ALGORITHM_VERSION
from src.utils.maps import dependencies_map, identifiers_map

if TYPE_CHECKING:
    from src.models import ModuleInfo
# ---------------------------------------------------------------------------------------------------------------------

# OPERATIONS / CLASS CREATION / GENERAL FUNCTIONS
# ---------------------------------------------------------------------------------------------------------------------

__all__ = ['render_graphic']

FILE = 'Graphic'

CLUSTER_BG = "#f5f5f5"
NODE_FILL = "#ffffff"
NODE_BORDER = "#aaaaaa"
EDGE_INTRA = "#444444"
EDGE_INTER = "#1f77b4"

def render_graphic(
    modules: List[ModuleInfo], 
    output: str, 
    repository: str, 
    framework: str, 
    *, 
    format: str = 'svg'
) -> Path:
    """
    Generates the dependency graph found between the analyzed modules.

    This method builds the internal dependency map of the code, invokes the generation of the corresponding graph, 
    and physically stores it in the user-defined path. The graph is generated according to the type of framework 
    evaluated, since each framework requires a different analysis of how the modules are structured.

    Args:
        modules (List[ModuleInfo]):
            List of `ModuleInfo` objects representing the analyzed modules in the repository.
        output (str):
            Path of the directory where the file will be stored. If it does not exist, it is created automatically.
        repository (str):
            Base path of the repository or project to be analyzed.
        framework (str):
            Name of the framework used, which must have a compatible mapping method.
        format (str, optional):
            Final format of the graph file.
    
    Returns:
        Path:
            Absolute path of the generated output file.
    """
    out = Path(output) / f'{FILE}.{format}'
    dep_map: Dict[str, Set] = dependencies_map(modules, repository, framework)
    graph = _map_to_graphic(repository, dep_map, format)
    graph.render(out.with_suffix(''), cleanup=True)
    return out

def _map_to_graphic(repository: str, dep_map: Dict[str, Set[str]], format: str) -> Digraph:
    """
    Construct a repository dependency diagram using Graphviz.

    Starting with a dependency map between modules, this function generates a directed graph where:
        - Each node represents a module (file) in the repository.
        - Nodes are grouped into clusters based on their parent folder.
        - Each folder is drawn as a rectangle (cluster) with its name as the label.
        - Edges indicate dependencies between modules.
        - Edges within the same cluster use the color `EDGE_INTRA`.
        - Edges between clusters use the color `EDGE_INTER`.
        - An invisible `wrapper` cluster is created for each folder to increase the visual separation 
        between groups of modules.

    Additionally, a header is added with the algorithm version and the name of the analyzed repository.

    Args:
        repository (str):
            Base path of the repository or project to be analyzed.
        dep_map(Dict[str, Set[str]]): 
            Dictionary where each key is a module and its value is a set of modules on which 
            it depends.
        format (str): 
            Output format supported by Graphviz.

    Returns:
        Digraph: 
            Graphviz object ready to be rendered in the specified format.
    """
    title = f'Dependency diagram generated by Codemnesis - v.{ALGORITHM_VERSION}\n\n'
    subtitle = f'Repository analyzed: {Path(repository).resolve().name}'
    
    dot = Digraph(
        format=format,
        graph_attr={
            'rankdir': 'LR',
            'splines': 'ortho',
            'concentrate': 'true',
            'label': f'{title}{subtitle}',
            'labelloc': 't',
            'fontsize': '62',
            'pad': '1.5',
            'nodesep': '1.5'
        },
        node_attr={ # Default style of nodes
            'shape': 'ellipse',
            'style': 'filled',
            'fillcolor': NODE_FILL,
            'color': NODE_BORDER,
            'fontsize': '44'
        }
    )

    all_path = _module_paths(dep_map)

    # Internal map that associates each module path with a short, unique identifier
    # This avoids problems with long paths and ensures valid IDs for Graphviz
    id_map = identifiers_map(all_path)

    groups: Dict[str, List[str]] = {}
    for path in all_path:
        name = Path(path).parent.name or 'root'
        groups.setdefault(name, []).append(path)

    # For each folder (group), two subgraphs are created:
    #   outer: invisible wrapper that helps space clusters
    #   inner: actual cluster with colored background and folder label
    for name, paths in groups.items():
        outer = Digraph(name=f'cluster_wrap_{name.lower()}')
        outer.attr(
            style='invis',
            color='none',
            peripheries='0'
        )

        inner = Digraph(name=f'cluster_{name.lower()}')
        inner.attr(
            label=name,
            style='rounded,filled',
            color=CLUSTER_BG,
            fillcolor=CLUSTER_BG,
            fontsize='48'
        )

        # Creation of nodes within the cluster
        for path in paths:
            inner.node(id_map[path], Path(path).stem)

        outer.subgraph(inner)
        dot.subgraph(outer)

    # Creation of dependency edges between modules
    for src, targets in dep_map.items():
        src_name = Path(src).parent.name or 'root'
        src_id = id_map[src]

        for dest in targets:
            dest_name = Path(dest).parent.name or 'root'
            dest_id = id_map[dest]

            same_group = (src_name == dest_name)
            dot.edge(src_id, dest_id, color=EDGE_INTER if same_group else EDGE_INTRA)

    return dot

def _module_paths(dep_map: Dict[str, Set[str]]) -> List[str]:
    """
    This function retrieves the complete list of module paths present in the dependency map.

    **It extracts:**
        - all keys from the dictionary (source modules)
        - all values ​​for each key (target modules)

    Then it combines both sets, removes duplicates, and returns them sorted.

    Args:
        dep_map(Dict[str, Set[str]]): 
            Dictionary where each key is a module and its value is a set of modules on which 
            it depends.

    Returns:
        List: 
            Alphabetically ordered list with all the unique paths detected.
    """
    all_path = list(dep_map.keys())

    # All modules that appear only as destinations must be added
    for path in dep_map.values():
        all_path.extend(list(path))

    return sorted(set(all_path))

# ---------------------------------------------------------------------------------------------------------------------
# END OF FILE