# MODULES (EXTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
from pathlib import Path
from graphviz import Digraph
from typing import List, Dict, Set
# ---------------------------------------------------------------------------------------------------------------------

# MODULES (INTERNAL)
# ---------------------------------------------------------------------------------------------------------------------
from configuration.constants import ALGORITHM_VERSION
# ---------------------------------------------------------------------------------------------------------------------

# OPERATIONS / CLASS CREATION / GENERAL FUNCTIONS
# ---------------------------------------------------------------------------------------------------------------------

__all__ = ['map_to_graph']

CLUSTER_BG   = "#f5f5f5"
NODE_FILL    = "#ffffff"
NODE_BORDER  = "#aaaaaa"
EDGE_INTRA   = "#444444"
EDGE_INTER   = "#1f77b4"

def map_to_graph(repository: str, dep_map: Dict[str, Set[str]], format: str) -> Digraph:
    """
    Construct a repository dependency diagram using Graphviz.

    Starting with a dependency map between modules, this function generates a directed graph where:
        - Each node represents a module (file) in the repository.
        - Nodes are grouped into clusters based on their parent folder.
        - Each folder is drawn as a rectangle (cluster) with its name as the label.
        - Edges indicate dependencies between modules.
        - Edges within the same cluster use the color `EDGE_INTRA`.
        - Edges between clusters use the color `EDGE_INTER`.
        - An invisible `wrapper` cluster is created for each folder to increase the visual separation 
        between groups of modules.

    Additionally, a header is added with the algorithm version and the name of the analyzed repository.

    Args:
        repository (str):
            Base path of the repository or project to be analyzed.
        dep_map(Dict[str, Set[str]]): 
            Dictionary where each key is a module and its value is a set of modules on which 
            it depends.
        format (str): 
            Output format supported by Graphviz.

    Returns:
        Digraph: 
            Graphviz object ready to be rendered in the specified format.
    """
    title = f'''
    Dependency diagram generated by AutoDocMind - v.{ALGORITHM_VERSION}
    \nRepository analyzed: {Path(repository).resolve().name}
    '''
    
    dot = Digraph(format=format)

    dot.attr(
        rankdir='LR',
        splines='ortho',
        concentrate='true',
        label=title,
        labelloc='t',
        fontsize='62',
        pad='1.5',
        nodesep='1.5'
    )

    dot.attr(
        'node',
        shape='ellipse',
        style='filled',
        fillcolor=NODE_FILL,
        color=NODE_BORDER,
        fontsize='44'
    )

    all_path = _get_all_path(dep_map)

    id_map = _build_id_map(all_path)

    groups: Dict[str, List[str]] = {}
    for path in all_path:
        name = Path(path).parent.name or 'root'
        groups.setdefault(name, []).append(path)

    for name, paths in groups.items():
        outer = Digraph(name=f'cluster_wrap_{name.lower()}')
        outer.attr(
            style='invis',
            color='none',
            peripheries='0'
        )

        inner = Digraph(name=f'cluster_{name.lower()}')
        inner.attr(
            label=name,
            style='rounded,filled',
            color=CLUSTER_BG,
            fillcolor=CLUSTER_BG,
            fontsize='48'
        )

        for path in paths:
            inner.node(
                id_map[path],
                _short_label(path)
            )

        outer.subgraph(inner)
        dot.subgraph(outer)

    for src, targets in dep_map.items():
        src_name = Path(src).parent.name or 'root'
        src_id = id_map[src]

        for dst in targets:
            dst_name = Path(dst).parent.name or 'root'
            dst_id = id_map[dst]

            if src_name != dst_name:
                dot.edge(src_id, dst_id, color=EDGE_INTRA)
            else:
                dot.edge(src_id, dst_id, color=EDGE_INTER)

    return dot

def _get_all_path(dep_map: Dict[str, Set[str]]) -> List[str]:
    """
    This function retrieves the complete list of module paths present in the dependency map.

    **It extracts:**
        - all keys from the dictionary (source modules)
        - all values ​​for each key (target modules)

    Then it combines both sets, removes duplicates, and returns them sorted.

    Args:
        dep_map(Dict[str, Set[str]]): 
            Dictionary where each key is a module and its value is a set of modules on which 
            it depends.

    Returns:
        List[str]: 
            Alphabetically ordered list with all the unique paths detected.
    """
    all_path = list(dep_map.keys())

    for path in dep_map.values():
        all_path.extend(list(path))

    return sorted(set(all_path))

def _build_id_map(all_path: List[str]) -> Dict[str, str]:
    """
    Build a dictionary that assigns an internal identifier to each module.

    Because Graphviz doesn't work well with long paths or special characters within node 
    identifiers, this function generates simplified identifiers in the format: `m0`, `m1`, `m2`, `...`

    Args:
        all_path(List[str]):
            Alphabetically ordered list with all the unique paths detected.

    Returns:
        Dict:
            Dictionary where the keys are module paths and the values ​​are simplified identifiers.
    """
    return {path: f'm{idx}' for idx, path in enumerate(all_path)}

def _short_label(path: str) -> str:
    """
    Generates a short, readable label to represent a module in the diagram.

    Given a full path, it returns only the filename without the extension.

    Args:
        path (str): 
            Path or filename.

    Returns:
        str: 
            Base filename without extension.
    """
    return Path(path).stem

# ---------------------------------------------------------------------------------------------------------------------
# END OF FILE